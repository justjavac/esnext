<!DOCTYPE html>
<html lang="zh-cn">
<head prefix="og: http://ogp.me/ns#"><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>异步迭代器 | esnext | es6 es7 es2017 es2018 es2019</title>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="http://esnext.justjavac.com/proposal/async-iteration.html">
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/icon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icon/favicon-16x16.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/icon/ms-icon-144x144.png">
  <meta name="theme-color" content="#2f83cd">
  <!-- CSS -->
  <link rel="stylesheet" href="/build/css/navy-ae512ba918.css">
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <!-- RSS -->
  <link rel="alternate" href="/atom.xml" title="esnext | es6 es7 es2017 es2018 es2019">
  <!-- Open Graph -->
  <meta name="description" content="1. 概述在 ECMAScript 2015(ES6) 中 JavaScript 引入了迭代器接口（iterator）用来遍历数据。迭代器对象知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在  JavaScript 中迭代器是一个对象，它提供了一个 next() 方法，用来返回序列中的下一项。这个方法返回包含两个属性：done 和 value。 迭代器对象一旦被创建，就可以反复调用 n">
<meta property="og:type" content="website">
<meta property="og:title" content="异步迭代器">
<meta property="og:url" content="http://esnext.justjavac.com/proposal/async-iteration.html">
<meta property="og:site_name" content="esnext | es6 es7 es2017 es2018 es2019">
<meta property="og:description" content="1. 概述在 ECMAScript 2015(ES6) 中 JavaScript 引入了迭代器接口（iterator）用来遍历数据。迭代器对象知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在  JavaScript 中迭代器是一个对象，它提供了一个 next() 方法，用来返回序列中的下一项。这个方法返回包含两个属性：done 和 value。 迭代器对象一旦被创建，就可以反复调用 n">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-07-12T02:11:43.302Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="异步迭代器">
<meta name="twitter:description" content="1. 概述在 ECMAScript 2015(ES6) 中 JavaScript 引入了迭代器接口（iterator）用来遍历数据。迭代器对象知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在  JavaScript 中迭代器是一个对象，它提供了一个 next() 方法，用来返回序列中的下一项。这个方法返回包含两个属性：done 和 value。 迭代器对象一旦被创建，就可以反复调用 n">
<meta name="twitter:site" content="justjavac">
 <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1f336f31cd6db48ca0ad520a9c7e4c57";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
</head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/" id="logo">Hexo</a>
    </h1>
    <nav id="main-nav">
      <a href="/proposal/exponentiation-operator.html" class="main-nav-link">提案</a><a href="/api/Array.prototype.includes.html" class="main-nav-link">API</a><a href="/news/" class="main-nav-link">文章</a><a href="/plugins/" class="main-nav-link">插件</a>
      <a target="_blank" href="https://github.com/justjavac/esnext" class="main-nav-link"><i class="fa fa-github-alt"></i></a>
    </nav>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">异步迭代器</h1>
                <a href="https://github.com/justjavac/esnext/edit/master/source/proposal/async-iteration.md" class="article-edit-link" title="改进本文"><i class="fa fa-pencil"></i></a>
              </header>
              <div class="article-content" itemprop="articleBody">
                <h2 id="1-概述" class="article-heading"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述<a class="article-anchor" href="#1-概述" aria-hidden="true"></a></h2><p>在 ECMAScript 2015(ES6) 中 JavaScript 引入了迭代器接口（iterator）用来遍历数据。迭代器对象知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在  JavaScript 中迭代器是一个对象，它提供了一个 <code>next()</code> 方法，用来返回序列中的下一项。这个方法返回包含两个属性：<code>done</code> 和 <code>value</code>。</p>
<p>迭代器对象一旦被创建，就可以反复调用 <code>next()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextIndex = <span class="number">0</span>;  <span class="comment">// 初始索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个迭代器对象，对象的属性是一个 next 方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nextIndex &lt; array.length) &#123;</span><br><span class="line">        <span class="comment">// 当没有到达末尾时，返回当前值，并把索引加1</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 到达末尾，done 属性为 true</span></span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦初始化，<code>next()</code> 方法可以用来依次访问对象中的键值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> it = makeIterator([<span class="string">'j'</span>, <span class="string">'u'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>]);</span><br><span class="line">it.next().value;  <span class="comment">// j</span></span><br><span class="line">it.next().value;  <span class="comment">// u</span></span><br><span class="line">it.next().value;  <span class="comment">// s</span></span><br><span class="line">it.next().value;  <span class="comment">// t</span></span><br><span class="line">it.next().value;  <span class="comment">// undefined</span></span><br><span class="line">it.next().done;   <span class="comment">// true</span></span><br><span class="line">it.next().value;  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="2-可迭代对象" class="article-heading"><a href="#2-可迭代对象" class="headerlink" title="2. 可迭代对象"></a>2. 可迭代对象<a class="article-anchor" href="#2-可迭代对象" aria-hidden="true"></a></h2><p>一个定义了<strong>迭代行为</strong>的对象，比如在 <code>for...of</code> 中循环了哪些值。为了实现可迭代，一个对象必须实现 <code>@@iterator</code> 方法，这意味着这个对象（或其原型链中的一个对象）必须具有带 <code>Symbol.iterator</code> 键的属性：</p>
<p><code>String</code>，<code>Array</code>，<code>TypedArray</code>，<code>Map</code> 和 <code>Set</code> 都内置可迭代对象，因为它们的原型对象都有一个 <code>Symbol.iterator</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> justjavac = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> items = [<span class="string">`j`</span>, <span class="string">`u`</span>, <span class="string">`s`</span>, <span class="string">`t`</span>, <span class="string">`j`</span>, <span class="string">`a`</span>, <span class="string">`v`</span>, <span class="string">`a`</span>, <span class="string">`c`</span>];</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        done: items.length === <span class="number">0</span>,</span><br><span class="line">        value: items.shift()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们定义了可迭代对象后，就可以在 <code>Array.from</code>、<code>for...of</code> 中使用这个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...justjavac];</span><br><span class="line"><span class="comment">// ["j", "u", "s", "t", "j", "a", "v", "a", "c"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(justjavac)</span><br><span class="line"><span class="comment">// ["j", "u", "s", "t", "j", "a", "v", "a", "c"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(justjavac);</span><br><span class="line"><span class="comment">// &#123;"j", "u", "s", "t", "a", "v", "c"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> justjavac) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j </span></span><br><span class="line"><span class="comment">// u </span></span><br><span class="line"><span class="comment">// s </span></span><br><span class="line"><span class="comment">// t </span></span><br><span class="line"><span class="comment">// j </span></span><br><span class="line"><span class="comment">// a </span></span><br><span class="line"><span class="comment">// v </span></span><br><span class="line"><span class="comment">// a </span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<h2 id="3-同步迭代" class="article-heading"><a href="#3-同步迭代" class="headerlink" title="3. 同步迭代"></a>3. 同步迭代<a class="article-anchor" href="#3-同步迭代" aria-hidden="true"></a></h2><p>由于在迭代器方法返回时，序列中的下一个值和数据源的 “done” 状态必须已知，所以迭代器只适合于表示<strong>同步</strong>数据源。</p>
<p>虽然 JavaScript 程序员遇到的许多数据源是同步的（比如内存中的列表和其他数据结构），但是其他许多数据源却不是。例如，任何需要 I/O 访问的数据源通常都会使用基于事件的或流式异步 API 来表示。不幸的是，迭代器不能用来表示这样的数据源。</p>
<p>（即使是 promise 的迭代器也是不够的，因为它的 value 是异步的，但是迭代器需要同步确定 “done” 状态。）</p>
<p>为了给异步数据源提供通用的数据访问协议，我们引入了 <code>AsyncIterator</code> 接口，异步迭代语句（<code>for-await-of</code>）和异步生成器函数。</p>
<h2 id="4-异步迭代器" class="article-heading"><a href="#4-异步迭代器" class="headerlink" title="4. 异步迭代器"></a>4. 异步迭代器<a class="article-anchor" href="#4-异步迭代器" aria-hidden="true"></a></h2><p>一个异步迭代器就像一个迭代器，除了它的 <code>next()</code> 方法返回一个 <code>{ value, done }</code> 的 promise。如上所述，我们必须返回迭代器结果的 promise，因为在迭代器方法返回时，迭代器的下一个值和“完成”状态可能未知。</p>
<p>我们修改一下之前的代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> const justjavac = &#123;</span><br><span class="line"><span class="deletion">-  [Symbol.iterator]: () =&gt; &#123;</span></span><br><span class="line"><span class="addition">+  [Symbol.asyncIterator]: () =&gt; &#123;</span></span><br><span class="line">     const items = [`j`, `u`, `s`, `t`, `j`, `a`, `v`, `a`, `c`];</span><br><span class="line">     return &#123;</span><br><span class="line"><span class="deletion">-      next: () =&gt; (&#123;</span></span><br><span class="line"><span class="addition">+      next: () =&gt; Promise.resolve(&#123;</span></span><br><span class="line">         done: items.length <span class="comment">=== 0,</span></span><br><span class="line">         value: items.shift()</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>好的，我们现在有了一个异步迭代器，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> justjavac = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.asyncIterator]: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> items = [<span class="string">`j`</span>, <span class="string">`u`</span>, <span class="string">`s`</span>, <span class="string">`t`</span>, <span class="string">`j`</span>, <span class="string">`a`</span>, <span class="string">`v`</span>, <span class="string">`a`</span>, <span class="string">`c`</span>];</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">        done: items.length === <span class="number">0</span>,</span><br><span class="line">        value: items.shift()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用如下代码进行遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> item <span class="keyword">of</span> justjavac) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你遇到了 <code>SyntaxError: for await (... of ...) is only valid in async functions and async generators</code> 错误，那是因为 <code>for-await-of</code> 只能在 async 函数或者 async 生成器里面使用。</p>
<p>修改一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> item <span class="keyword">of</span> justjavac) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="5-同步迭代器-vs-异步迭代器" class="article-heading"><a href="#5-同步迭代器-vs-异步迭代器" class="headerlink" title="5. 同步迭代器 vs 异步迭代器"></a>5. 同步迭代器 vs 异步迭代器<a class="article-anchor" href="#5-同步迭代器-vs-异步迭代器" aria-hidden="true"></a></h2><h3 id="5-1-Iterators" class="article-heading"><a href="#5-1-Iterators" class="headerlink" title="5.1 Iterators"></a>5.1 Iterators<a class="article-anchor" href="#5-1-Iterators" aria-hidden="true"></a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">interface Iterator &#123;</span><br><span class="line">    next(value) : IteratorResult;</span><br><span class="line">    [optional] <span class="keyword">throw</span>(value) : IteratorResult;</span><br><span class="line">    [optional] <span class="keyword">return</span>(value) : IteratorResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代结果</span></span><br><span class="line">interface IteratorResult &#123;</span><br><span class="line">    value : any;</span><br><span class="line">    done : bool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Async-Iterators" class="article-heading"><a href="#5-2-Async-Iterators" class="headerlink" title="5.2 Async Iterators"></a>5.2 Async Iterators<a class="article-anchor" href="#5-2-Async-Iterators" aria-hidden="true"></a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步迭代器</span></span><br><span class="line">interface AsyncIterator &#123;</span><br><span class="line">    next(value) : <span class="built_in">Promise</span>&lt;IteratorResult&gt;;</span><br><span class="line">    [optional] <span class="keyword">throw</span>(value) : <span class="built_in">Promise</span>&lt;IteratorResult&gt;;</span><br><span class="line">    [optional] <span class="keyword">return</span>(value) : <span class="built_in">Promise</span>&lt;IteratorResult&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代结果</span></span><br><span class="line">interface IteratorResult &#123;</span><br><span class="line">    value : any;</span><br><span class="line">    done : bool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-异步生成器函数" class="article-heading"><a href="#6-异步生成器函数" class="headerlink" title="6. 异步生成器函数"></a>6. 异步生成器函数<a class="article-anchor" href="#6-异步生成器函数" aria-hidden="true"></a></h2><p>异步生成器函数与生成器函数类似，但有以下区别：</p>
<ul>
<li>当被调用时，异步生成器函数返回一个对象，”async generator”，含有 3 个方法（<code>next</code>，<code>throw</code>，和<code>return</code>），每个方法都返回一个 Promise，Promise 返回 <code>{ value, done }</code>。而普通生成器函数并不返回 Promise，而是直接返回 <code>{ value, done }</code>。这会自动使返回的异步生成器对象具有异步迭代的功能。</li>
<li>允许使用 <code>await</code> 表达式和 <code>for-await-of</code> 语句。</li>
<li>修改了 <code>yield*</code> 的行为以支持异步迭代。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">readLines</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">await</span> fileOpen(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!file.EOF) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">await</span> file.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数返回一个异步生成器（async generator）对象，可以用在 <code>for-await-of</code> 语句中。</p>
<h2 id="7-实现" class="article-heading"><a href="#7-实现" class="headerlink" title="7. 实现"></a>7. 实现<a class="article-anchor" href="#7-实现" aria-hidden="true"></a></h2><ul>
<li><a href="https://github.com/Microsoft/ChakraCore/issues/2720" target="_blank" rel="noopener">Chakra</a> - 暂未支持</li>
<li><a href="https://github.com/tc39/proposal-async-iteration/issues/63#issuecomment-330929480" target="_blank" rel="noopener">JavaScriptCore</a> - Safari Tech Preview 40</li>
<li><a href="https://github.com/tc39/proposal-async-iteration/issues/63#issuecomment-330978069" target="_blank" rel="noopener">SpiderMonkey</a> - Firefox 57</li>
<li><a href="https://blog.chromium.org/2017/10/chrome-63-beta-dynamic-module-imports_27.html" target="_blank" rel="noopener">V8</a> - Chrome 63</li>
</ul>
<h2 id="Polyfills" class="article-heading"><a href="#Polyfills" class="headerlink" title="Polyfills"></a>Polyfills<a class="article-anchor" href="#Polyfills" aria-hidden="true"></a></h2><p>Facebook 的 <a href="https://github.com/facebook/regenerator" target="_blank" rel="noopener">Regenerator</a> 项目为 <code>AsyncIterator</code> 接口提供了一个 polyfill，将异步生成器函数变成返回 <code>AsyncIterator</code> 的对象 ECMAScript 5 函数。Regenerator 还不支持 <code>for-await-of</code> 异步迭代语法。</p>
<p><a href="https://github.com/babel/babel/tree/master/packages/babylon" target="_blank" rel="noopener">Babylon parser</a> 项目支持异步生成器函数和 <code>for- await-of</code> 语句（v6.8.0+）。你可以使用它的 <a href="https://github.com/babel/babel/tree/master/packages/babylon#plugins" target="_blank" rel="noopener">asyncGenerators 插件</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"babylon"</span>).parse(<span class="string">"code"</span>, &#123;</span><br><span class="line">  sourceType: <span class="string">"module"</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">"asyncGenerators"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外，从 6.16.0 开始，异步迭代被包含在 Babel 的 <a href="https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-async-generator-functions" target="_blank" rel="noopener"><code>&quot;babel-plugin-transform-async-generator-functions&quot;</code></a> 下以及 <a href="http://babeljs.io/docs/plugins/preset-stage-3/" target="_blank" rel="noopener"><code>babel-preset-stage-3</code></a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"babel-core"</span>).transform(<span class="string">"code"</span>, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">"transform-async-generator-functions"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2019-07-12T02:11:43.302Z" itemprop="dateModified">上次更新：2019-07-12</time>
                <a href="object-rest-spread.html" class="article-footer-prev" title="对象展开运算符"><i class="fa fa-chevron-left"></i><span>上一页</span></a><a href="regexp-lookbehind.html" class="article-footer-next" title="正则表达式反向(后向)断言"><span>下一页</span><i class="fa fa-chevron-right"></i></a>
              </footer>
              
            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-概述"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-可迭代对象"><span class="toc-text">2. 可迭代对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-同步迭代"><span class="toc-text">3. 同步迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-异步迭代器"><span class="toc-text">4. 异步迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-同步迭代器-vs-异步迭代器"><span class="toc-text">5. 同步迭代器 vs 异步迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Iterators"><span class="toc-text">5.1 Iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Async-Iterators"><span class="toc-text">5.2 Async Iterators</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-异步生成器函数"><span class="toc-text">6. 异步生成器函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-实现"><span class="toc-text">7. 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Polyfills"><span class="toc-text">Polyfills</span></a></li></ol>
              <a href="#" id="article-toc-top">回到顶部</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <strong class="sidebar-title">ES2016</strong><a href="exponentiation-operator.html" class="sidebar-link">幂运算符(**)</a><strong class="sidebar-title">ES2017</strong><a href="ecmascript-asyncawait.html" class="sidebar-link">异步函数</a><a href="ecmascript_sharedmem.html" class="sidebar-link">共享内存和原子操作</a><a href="trailing-function-commas.html" class="sidebar-link">函数参数的末尾逗号</a><strong class="sidebar-title">ES2018</strong><a href="template-literal-revision.html" class="sidebar-link">非转义序列的模板字符串</a><a href="regexp-dotall-flag.html" class="sidebar-link">正则表达式 <code>dotAll</code> 模式</a><a href="regexp-named-groups.html" class="sidebar-link">正则表达式命名捕获组</a><a href="object-rest-spread.html" class="sidebar-link">对象展开运算符</a><strong class="sidebar-title">Stage4</strong><a href="async-iteration.html" class="sidebar-link current">异步迭代器</a><a href="regexp-lookbehind.html" class="sidebar-link">正则表达式反向(后向)断言</a><a href="regexp-unicode-property-escapes.html" class="sidebar-link">正则表达式 Unicode 转义</a><strong class="sidebar-title">FAQ</strong><a href="reserved-words.html" class="sidebar-link">保留字</a>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-5061364613986259"
        data-ad-slot="9593020197"
        data-ad-format="auto"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </div>
</aside>

    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2019 <a href="https://github.com/justjavac/esnext/graphs/contributors" target="_blank">esnext</a><br>
      本网站内容基于 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank">CC BY-NC-SA 4.0</a> 许可协议发布
    </div>
    <div id="footer-links">
      <a href="https://weibo.com/justjavac" class="footer-link" target="_blank"><i class="fa fa-weibo"></i></a>
      <a href="https://github.com/justjavac/esnext" class="footer-link" target="_blank"><i class="fa fa-github-alt"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/proposal/exponentiation-operator.html" class="mobile-nav-link">提案</a><a href="/api/Array.prototype.includes.html" class="mobile-nav-link">API</a><a href="/news/" class="mobile-nav-link">文章</a><a href="/plugins/" class="mobile-nav-link">插件</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/justjavac/esnext" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">ES2016</strong><a href="exponentiation-operator.html" class="mobile-nav-link">幂运算符(**)</a><strong class="mobile-nav-title">ES2017</strong><a href="ecmascript-asyncawait.html" class="mobile-nav-link">异步函数</a><a href="ecmascript_sharedmem.html" class="mobile-nav-link">共享内存和原子操作</a><a href="trailing-function-commas.html" class="mobile-nav-link">函数参数的末尾逗号</a><strong class="mobile-nav-title">ES2018</strong><a href="template-literal-revision.html" class="mobile-nav-link">非转义序列的模板字符串</a><a href="regexp-dotall-flag.html" class="mobile-nav-link">正则表达式 <code>dotAll</code> 模式</a><a href="regexp-named-groups.html" class="mobile-nav-link">正则表达式命名捕获组</a><a href="object-rest-spread.html" class="mobile-nav-link">对象展开运算符</a><strong class="mobile-nav-title">Stage4</strong><a href="async-iteration.html" class="mobile-nav-link current">异步迭代器</a><a href="regexp-lookbehind.html" class="mobile-nav-link">正则表达式反向(后向)断言</a><a href="regexp-unicode-property-escapes.html" class="mobile-nav-link">正则表达式 Unicode 转义</a><strong class="mobile-nav-title">FAQ</strong><a href="reserved-words.html" class="mobile-nav-link">保留字</a>
    
  </div>
</nav>
  <!-- Scripts -->
<script src="/build/js/main-5d0f56746e.js"></script>


</body>
</html>